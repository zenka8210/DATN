'use client';
import { useState, useEffect, useRef, useCallback } from 'react';
import styles from './FlashSale.module.css';
import Prod        if (saleProducts.length > 0) {
          console.log('üõçÔ∏è Sample sale product:', saleProducts[0].name, 'price:', saleProducts[0].price, '‚Üí', saleProducts[0].salePrice);
          // Calculate countdown based on real sale end dates if available
          calculateSaleEndTime(saleProducts);
        }/app/components/ProductItem';
import { ProductWithCategory } from '@/types';
import { FaChevronLeft, FaChevronRight, FaFire, FaClock, FaBolt } from 'react-icons/fa';
import { useProducts } from '@/hooks/useProducts';
import { LoadingSpinner } from '@/app/components/ui';

interface FlashSaleProps {
  maxProducts?: number;
  autoSlide?: boolean;
  slideInterval?: number;
}

export default function FlashSale({ 
  maxProducts = 20, 
  autoSlide = true, 
  slideInterval = 5000 
}: FlashSaleProps) {
  const { getProducts, loading } = useProducts();
  const [flashSaleProducts, setFlashSaleProducts] = useState<ProductWithCategory[]>([]);
  const [totalAvailableProducts, setTotalAvailableProducts] = useState(0);
  const [currentSlide, setCurrentSlide] = useState(0);
  const [timeLeft, setTimeLeft] = useState({
    hours: 0,
    minutes: 0,
    seconds: 0
  });
  const [saleEndTime, setSaleEndTime] = useState<Date | null>(null);

  const autoSlideRef = useRef<NodeJS.Timeout | null>(null);
  
  // Calculate realistic sale end time based on flash sale logic
  const calculateSaleEndTime = useCallback((products: ProductWithCategory[]) => {
    console.log('üïí Calculating sale end time for products:', products.length);
    
    // Check if any product has real saleEndDate
    const productsWithSaleDate = products.filter(p => 
      p.saleEndDate && new Date(p.saleEndDate) > new Date()
    );
    
    if (productsWithSaleDate.length > 0) {
      // Use the earliest sale end date
      const earliestEndDate = productsWithSaleDate
        .map(p => new Date(p.saleEndDate!))
        .sort((a, b) => a.getTime() - b.getTime())[0];
      
      console.log('‚úÖ Using real sale end date:', earliestEndDate);
      setSaleEndTime(earliestEndDate);
      return;
    }
    
    // For flash sale products (based on time), calculate realistic end time
    const now = new Date();
    const currentHour = now.getHours();
    
    // Flash sale runs 9AM-9PM, so calculate end time accordingly
    if (currentHour >= 9 && currentHour < 21) {
      // Sale ends at 9 PM today
      const endTime = new Date();
      endTime.setHours(21, 0, 0, 0);
      console.log('‚úÖ Using daily flash sale end time (9 PM):', endTime);
      setSaleEndTime(endTime);
    } else {
      // Sale starts again at 9 AM next day
      const nextSaleStart = new Date();
      if (currentHour >= 21) {
        // If after 9 PM, next sale starts tomorrow 9 AM
        nextSaleStart.setDate(nextSaleStart.getDate() + 1);
      }
      nextSaleStart.setHours(21, 0, 0, 0); // End at 9 PM next day
      console.log('‚úÖ Using next day flash sale end time:', nextSaleStart);
      setSaleEndTime(nextSaleStart);
    }
  }, []);

  // Update countdown timer based on real sale data
  const updateCountdown = useCallback(() => {
    if (!saleEndTime) return;
    
    const now = new Date();
    const distance = saleEndTime.getTime() - now.getTime();
    
    if (distance > 0) {
      const hours = Math.floor(distance / (1000 * 60 * 60));
      const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((distance % (1000 * 60)) / 1000);
      
      setTimeLeft({ hours, minutes, seconds });
    } else {
      // Sale ended, reset timer
      setTimeLeft({ hours: 0, minutes: 0, seconds: 0 });
      // Could trigger refetch here if needed
      console.log('‚è∞ Flash sale ended, timer reset');
    }
  }, [saleEndTime]);

  // C·ªë ƒë·ªãnh 4 s·∫£n ph·∫©m m·ªói slide (theo y√™u c·∫ßu)
  const productsPerSlide = 4;
  const totalSlides = Math.ceil(flashSaleProducts.length / productsPerSlide);

  // Fetch flash sale products - Use dynamic filtering approach
  const fetchFlashSaleProducts = useCallback(async () => {
    try {
      console.log('üîç FlashSale: Starting to fetch products for dynamic sale filtering...');
      
      // Fetch all sale products to get total count
      const response = await getProducts({
        isOnSale: true,
        limit: 500, // High limit to get total count
        sort: 'name',
        order: 'asc'
      });

      console.log('üì¶ FlashSale API response:', response);
      console.log('üìä Response data type:', typeof response?.data);
      console.log('üìä Response data length:', response?.data?.length);

      if (response?.data && response.data.length > 0) {
        // Filter to only show products with explicit database sale (same logic as sale page)
        const allSaleProducts = response.data
          .filter((product: ProductWithCategory) => {
            // Only show products with valid salePrice from database
            const hasValidSale = product.salePrice && 
                                product.salePrice > 0 && 
                                product.salePrice < product.price &&
                                product.isActive !== false;
            
            return hasValidSale;
          });
        
        // Set total count and limit display products
        setTotalAvailableProducts(allSaleProducts.length);
        const saleProducts = allSaleProducts.slice(0, maxProducts);
        
        setFlashSaleProducts(saleProducts);
        console.log('‚úÖ FlashSale: Successfully loaded', saleProducts.length, 'of', allSaleProducts.length, 'total sale products');
        
        if (saleProducts.length > 0) {
          console.log('üõçÔ∏è Sample sale product:', saleProducts[0].name, 'price:', saleProducts[0].price, '‚Üí', saleProducts[0].salePrice);
          // Calculate countdown based on real sale end dates if available
        } else {
          console.log('ÔøΩ Outside flash sale hours, showing products with explicit sales only');
          
          saleProducts = response.data
            .filter((product: ProductWithCategory) => 
              product.salePrice && product.salePrice < product.price
            )
            .slice(0, maxProducts);
        }
        
        setFlashSaleProducts(saleProducts);
        console.log('‚úÖ FlashSale: Successfully loaded', saleProducts.length, 'sale products');
        
        if (saleProducts.length > 0) {
          console.log('üõçÔ∏è First sale product:', saleProducts[0]);
          // Calculate realistic countdown based on sale data
          calculateSaleEndTime(saleProducts);
        }
      } else {
        console.log('‚ùå FlashSale: No products found in response');
        setFlashSaleProducts([]);
      }
    } catch (error) {
      console.error('‚ùå FlashSale Error:', error);
      setFlashSaleProducts([]);
    }
  }, [getProducts, maxProducts, calculateSaleEndTime]);

  // Initialize products
  useEffect(() => {
    fetchFlashSaleProducts();
  }, [fetchFlashSaleProducts]);

  // Real-time countdown timer based on sale data
  useEffect(() => {
    if (!saleEndTime) return;
    
    // Update immediately
    updateCountdown();
    
    // Update every second
    const timer = setInterval(updateCountdown, 1000);
    
    return () => clearInterval(timer);
  }, [saleEndTime, updateCountdown]);

  // Auto slide functionality
  useEffect(() => {
    if (autoSlide && totalSlides > 1) {
      autoSlideRef.current = setInterval(() => {
        setCurrentSlide(prev => (prev >= totalSlides - 1 ? 0 : prev + 1));
      }, slideInterval);

      return () => {
        if (autoSlideRef.current) {
          clearInterval(autoSlideRef.current);
        }
      };
    }
  }, [autoSlide, slideInterval, totalSlides]);

  // Manual slide controls
  const goToSlide = (slideIndex: number) => {
    if (autoSlideRef.current) {
      clearInterval(autoSlideRef.current);
    }
    setCurrentSlide(slideIndex);
  };

  const nextSlide = () => {
    goToSlide(currentSlide >= totalSlides - 1 ? 0 : currentSlide + 1);
  };

  const prevSlide = () => {
    goToSlide(currentSlide <= 0 ? totalSlides - 1 : currentSlide - 1);
  };

  // Modern business discount calculation - match backend logic
  const getDiscountPercent = (product: ProductWithCategory) => {
    // Priority 1: Real sale price (if exists)
    if (product.salePrice && product.salePrice < product.price) {
      return Math.round(((product.price - product.salePrice) / product.price) * 100);
    }
    
    // Priority 2: Flash sale based on price tiers (match backend)
    if (product.price >= 1000000) return 25; // Premium: 25% off
    if (product.price >= 500000) return 20;  // Mid-range: 20% off  
    if (product.price >= 200000) return 15;  // Budget: 15% off
    
    return 10; // Default: 10% off
  };

  // Format timer
  // Update countdown every second
  useEffect(() => {
    if (saleEndTime) {
      const timer = setInterval(updateCountdown, 1000);
      updateCountdown(); // Initial call
      
      return () => clearInterval(timer);
    }
  }, [saleEndTime]);

  // Check if the sale is still active (prevent showing expired countdown)
  useEffect(() => {
    if (flashSaleProducts.length > 0 && !saleEndTime) {
      calculateSaleEndTime(flashSaleProducts);
    }
  }, [flashSaleProducts, calculateSaleEndTime]);

  const formatTime = (time: number) => {
    return time.toString().padStart(2, '0');
  };

  // Debug log ƒë·ªÉ ki·ªÉm tra state
  console.log('üé¨ FlashSale Render State:', {
    loading,
    productsCount: flashSaleProducts.length,
    totalSlides,
    currentSlide
  });

  if (loading) {
    return (
      <div className={styles.flashSaleContainer}>
        <div className={styles.header}>
          <div className={styles.titleSection}>
            <h2 className={styles.title}>
              <FaFire className={styles.fireIcon} />
              <span className={styles.flashText}>FLASH</span>
              <span className={styles.saleText}>SALE</span>
            </h2>
          </div>
        </div>
        <div className={styles.productsSection}>
          <div className={styles.loadingContainer}>
            <LoadingSpinner size="lg" />
            <span className={styles.loadingText}>ƒêang t·∫£i s·∫£n ph·∫©m flash sale...</span>
          </div>
        </div>
      </div>
    );
  }

  if (flashSaleProducts.length === 0) {
    return (
      <div className={styles.flashSaleContainer}>
        <div className={styles.header}>
          <div className={styles.titleSection}>
            <h2 className={styles.title}>
              <FaFire className={styles.fireIcon} />
              <span className={styles.flashText}>FLASH</span>
              <span className={styles.saleText}>SALE</span>
            </h2>
          </div>
        </div>
        <div className={styles.productsSection}>
          <div className={styles.emptyState}>
            <FaFire className={styles.emptyStateIcon} />
            <h3 className={styles.emptyStateTitle}>Ch∆∞a c√≥ s·∫£n ph·∫©m Flash Sale</h3>
            <p className={styles.emptyStateText}>
              H√£y quay l·∫°i sau ƒë·ªÉ kh√¥ng b·ªè l·ª° nh·ªØng ∆∞u ƒë√£i h·∫•p d·∫´n nh·∫•t!
            </p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className={styles.flashSaleContainer}>
      {/* Header */}
      <div className={styles.header}>
        <div className={styles.titleSection}>
          <h2 className={styles.title}>
            <FaFire className={styles.fireIcon} />
            <span className={styles.flashText}>FLASH</span>
            <span className={styles.saleText}>SALE</span>
            <span className={styles.productCount}>({flashSaleProducts.length})</span>
          </h2>
          
          <div className={styles.subtitle}>
            <FaClock className={styles.clockIcon} />
            <span>K·∫øt th√∫c sau:</span>
            <div className={styles.countdown}>
              {timeLeft.hours > 0 && (
                <>
                  <span className={styles.timeUnit}>
                    {formatTime(timeLeft.hours)}
                    <small>h</small>
                  </span>
                  <span className={styles.timeSeparator}>:</span>
                </>
              )}
              <span className={styles.timeUnit}>
                {formatTime(timeLeft.minutes)}
                <small>m</small>
              </span>
              <span className={styles.timeSeparator}>:</span>
              <span className={styles.timeUnit}>
                {formatTime(timeLeft.seconds)}
                <small>s</small>
              </span>
            </div>
          </div>
        </div>
        
        <div className={styles.viewAllSection}>
          <a href="/sale" className={styles.viewAllLink}>
            Xem t·∫•t c·∫£
          </a>
        </div>
      </div>

      {/* Products Section */}
      <div className={styles.productsSection}>
        <div className={styles.sliderContainer}>
          {/* Navigation Buttons */}
          {totalSlides > 1 && (
            <>
              <button 
                className={`${styles.sliderNav} ${styles.sliderNavPrev}`}
                onClick={prevSlide}
                aria-label="Slide tr∆∞·ªõc"
              >
                <FaChevronLeft />
              </button>
              
              <button 
                className={`${styles.sliderNav} ${styles.sliderNavNext}`}
                onClick={nextSlide}
                aria-label="Slide ti·∫øp theo"
              >
                <FaChevronRight />
              </button>
            </>
          )}

          {/* Products Grid - 4 s·∫£n ph·∫©m m·ªói slide */}
          <div className={styles.sliderWrapper}>
            <div 
              className={styles.sliderTrack}
              style={{
                transform: `translateX(-${currentSlide * 100}%)`,
                transition: 'transform 0.3s ease-in-out'
              }}
            >
              {Array.from({ length: totalSlides }, (_, slideIndex) => (
                <div key={slideIndex} className={styles.slide}>
                  <div className={styles.productsGrid}>
                    {flashSaleProducts
                      .slice(slideIndex * 4, (slideIndex + 1) * 4)
                      .map((product) => (
                        <div key={product._id} className={styles.productSlot}>
                          <div className={styles.saleIndicator}>
                            <FaBolt className={styles.saleIcon} />
                            <span className={styles.discountText}>
                              -{getDiscountPercent(product)}%
                            </span>
                          </div>
                          
                          <ProductItem 
                            product={product} 
                            layout="grid"
                            showQuickActions={true}
                          />
                        </div>
                      ))}
                    
                    {/* Empty slots ƒë·ªÉ ƒë·∫£m b·∫£o lu√¥n c√≥ 4 slots */}
                    {Array.from({ 
                      length: 4 - flashSaleProducts.slice(slideIndex * 4, (slideIndex + 1) * 4).length 
                    }, (_, index) => (
                      <div key={`empty-${index}`} className={styles.emptySlot}>
                        <div className={styles.emptySlotContent}>
                          <FaClock className={styles.emptyIcon} />
                          <span>S·∫£n ph·∫©m s·∫Øp c√≥</span>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              ))}
            </div>
          </div>

          {/* Slide Indicators */}
          {totalSlides > 1 && (
            <div className={styles.slideIndicators}>
              {Array.from({ length: totalSlides }, (_, index) => (
                <button
                  key={index}
                  className={`${styles.indicator} ${
                    index === currentSlide ? styles.indicatorActive : ''
                  }`}
                  onClick={() => goToSlide(index)}
                  aria-label={`Slide ${index + 1}`}
                />
              ))}
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
